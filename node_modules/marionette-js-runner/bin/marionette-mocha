#! /usr/bin/env node
var Mocha = require('mocha'),
    Parent = require('../lib/parentrunner').ParentRunner,
    fs = require('fs'),
    fsPath = require('path'),
    resolveModule = require('../lib/resolvemodule');

/**
Path to marionette-mocha configuration file.
@type {string}
*/
var OPTS_FILE = 'marionette-mocha.opts';

/**
Options specific to the marionette-mocha wrapper that must be stripped before
being sent to the child.
*/
var OWNED_FLAGS = [
  'host',
  'manifest',
  'reporter', // reporter is manually set for the child
  'profile-base',
  'profileBase',
  'profile-builder',
  'profileBuilder',
  'runtime',
  'b2g-desktop-oop',
  'b2gDesktopOop',
  'mocha-flags',
  'mochaFlags'
];

/**
Sanitizes a parsed yargs argv to just the options that can be safely passed to
mocha in the child process...

@param {Object} args parsed by yargs.
@return {Array} argv to be passed to child process.
*/
function sanitizeOptionsForMocha(args) {
  var result = [];

  for (var key in args) {
    if (OWNED_FLAGS.indexOf(key) !== -1) continue;
    // yargs adds $0 for use with help skip it.
    if (key === '$0') continue;
    // skip the list of argv options.
    if (key === '_') continue;
    // skip any of the camel case field conversions.
    if (/[A-Z]/.test(key)) continue;

    result.push('--' + key)
    result.push(args[key]);
  }

  // Always append the final _ args which are the non-flags.
  return result.concat(args._);
}

/**
@return {Object} Configuration for Host, ProfileBuilder, Reporter,
                 and profileBase.
*/
function getOpts(argv) {
  var Reporter;
  try {
    Reporter = require(argv.reporter);
  } catch (e) {
    Reporter = require('mocha/lib/reporters/' + (argv.reporter || 'dot'));
  }

  argv.host = argv.host || 'marionette-b2gdesktop-host';
  argv.profileBuilder =
    argv.profileBuilder || 'marionette-profile-builder';

  var Host = require(argv.host),
      ProfileBuilder = require(argv.profileBuilder);

  // Parse base profile options.
  var profileBase;
  if (argv.profileBase) {
    // Remember because require is used json files or JS files can be used.
    // The path is resolved since it should be relative to cwd rather than this
    // executable.
    profileBase = require(fsPath.resolve(argv.profileBase));
  }

  // Whether or not to proxy console.* calls from gecko.
  var verbose = argv.verbose;

  return {
    Host: Host,
    ProfileBuilder: ProfileBuilder,
    Reporter: Reporter,
    profileBase: profileBase,
    verbose: verbose,
    runtime: argv.runtime
  };
}


/**
 * Look for marionette-mocha opts file and add any configuration we find
 *     to the program argv.
 * @param {string} path relative path to directory to look in.
 */
function maybeAppendOptsFileArgs(path) {
  var optsFile = fsPath.join(path, OPTS_FILE);
  if (!fs.existsSync(optsFile)) {
    return;
  }

  process.argv.splice.apply(
    process.argv,
    [2, 0].concat(require('../lib/optsfileparser')(optsFile))
  );
}


function main() {
  ['test/', 'tests', ''].forEach(maybeAppendOptsFileArgs);

  var program = require('yargs')
    .usage('Usage: $0 [options] <tests...>')
    .options('host', {
      desc: 'host module to use defaults to marionette-b2gdesktop-host'
    })
    .options('manifest', {
      desc: 'relative path to a JSON-formatted manifest file defining ' +
            'test runner whitelist or blacklist'
    })
    .options('reporter', {
      desc: 'mocha reporter to use'
    })
    .options('verbose', {
      desc: 'pipe console.* logs from child gecko processes to test process'
    })
    .options('profile-base', {
      desc: 'default profile options to use in all tests.'
    })
    .options('profile-builder', {
      desc: 'profile generation module'
    })
    .options('runtime', {
      desc: 'path to a custom binary to execute tests on'
    })
    .options('b2g-desktop-oop', {
      desc: 'enable oop mode for b2g desktop'
    })
    .options('ui', {
      desc: 'marionette specific ui to use',
      default: __dirname + '/../lib/ui'
    })
    .options('mocha-flags', {
      desc: 'show mocha help and flags'
    })
    .options('--serial', {
      desc: 'device serial ID to run tests against'
    })
    .options('--symbols-path', {
      desc: 'symbols for the build'
    })
    .options('--b2gpath', {
      desc: 'path to b2g directory for emulator builds'
    })
    .options('--buildapp', {
      desc: 'type of build to run gaia-integration tests on, one of "emulator", "device", or "desktop"'
    });

  var argv = program.argv;

  // Show the help message if requested...
  if (argv.help) {
    program.showHelp();
    process.exit(0)
  }

  // Show mocha help and flags if requested...
  if (argv.mochaFlags) {
    var mochaBin = resolveModule('mocha', 'bin', 'mocha');
    var proc = require('child_process').spawn(
      mochaBin, ['--help'], { stdio: 'inherit' }
    );

    proc.once('exit', process.exit);
    return;
  }

  // Process all the files through the whitelist/blacklist filter.
  if (argv.manifest) {
    var applyManifest = require('../lib/applymanifest');
    try {
      argv._ = applyManifest(argv.manifest, argv._);
    } catch (err) {
      console.error(err);
      process.exit(1);
    }
  }

  var runnerOpts = getOpts(argv);
  var mochaArgs = sanitizeOptionsForMocha(argv);

  var runner = new Parent(mochaArgs);
  runner.run(runnerOpts);
  runner.process.stdout.pipe(process.stdout);
  runner.process.stderr.pipe(process.stderr);
  runner.process.on('exit', process.exit);
}
if (require.main === module) {
  main();
}
