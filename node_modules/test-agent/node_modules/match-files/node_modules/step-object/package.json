{
  "name": "step-object",
  "description": "More Object based creation of 'step' functions",
  "keywords": [
    "step",
    "oop",
    "control flow"
  ],
  "main": "lib/step-object.js",
  "author": {
    "name": "James Lal",
    "email": "james@lightsofapollo.com"
  },
  "homepage": "https://github.com/lightsofapollo/step-object",
  "repository": {
    "type": "git",
    "url": "git://github.com:lightsofapollo/step-object.git"
  },
  "scripts": {
    "test": "make test"
  },
  "dependencies": {
    "step": "~0.0.5"
  },
  "devDependencies": {
    "mocha": "~0.10",
    "sinon": "~1.3",
    "expect.js": "*",
    "projstrap": "*",
    "sinon-expect": "*",
    "sinon-mocha": "0.0.2"
  },
  "version": "0.2.2",
  "readme": "Object based creation of step functions.\n\nStill an experiment at this stage.\n\n## Step Creation\n\n    var StepObject = require('step-object'),\n        fs = require('fs');\n\n    var ReadDir = StepObject({\n\n      _filter: function(files){\n        var filteredFiles;\n\n        //some filter logic\n        return filteredFiles;\n      },\n\n      queue: function(path){\n        fs.readdir(path, this);\n      },\n\n      read: function(err, files){\n        if(err){\n          throw err;\n        }\n\n        return this._filter(files);\n      },\n\n    }, ['queue', 'read']);\n\n    ReadDir(function(err, files){\n      //files is the result of read\n    });\n    \n    \n    \n\n## Testing\n\nOne problem I ran into using step initially was gaining access to the\nscope in which the steps actually execute in.\n\nI still perfer to specify the behaviour of each function which becomes\nvery difficult if these functions utlize the shared contex to store\ninformation.\n\nThe below will give you a reference to the the context the step\nexecution. This is the same object you refer to when using 'this' inside\nof your step methods.\n\n\n    //Note that this will not call queue from the above example\n    var subject = require('step-object/lib/mock-step-object')(ReadDir);\n\n    subject.queue //\n\n\nIts important for me to note that this works via a simple hack\nwhere by not returning anything in a function the step execution\nhalts because its effectivly waiting for a callback to execute.\n\nSo if you did the following:\n\n    subject(); \n    //(which is the same as `this()` or next inside of step scope)\n\n\nIt will cause werid things to happen such as two steps\nexecuting without waiting for the other to finish.\n\n\n### Group / Parallel\n\nThe `.group` and `.parallel` functions are overriden to return\nthemselves. This is so you can spy for them inside of your tests.\n\n## Methods / Order\n\nYou can also gain access to methods and order of the StepObject at\nanytime with:\n\n    ReadDir.methods //{queue: ....}\n    ReadDir.order //['queueRead', 'fsReadDir']\n\n\n\n## License\n\nSee LICENSE (MIT)\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/lightsofapollo/step-object/issues"
  },
  "_id": "step-object@0.2.2",
  "_shasum": "c2f123ed06abd62bb4ee41f8bb8d5bc234894f06",
  "_from": "step-object@0.2.2",
  "_resolved": "https://registry.npmjs.org/step-object/-/step-object-0.2.2.tgz"
}
