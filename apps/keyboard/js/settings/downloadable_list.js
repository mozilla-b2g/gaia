'use strict';

/* global Promise, DatabasePromiseManager, Downloadable */

(function(exports) {

var DownloadableList = function() {
  this.sectionElement = null;
  this.listElement = null;
  this.downloadables = null;
};

DownloadableList.prototype.SECTION_ELEMENT_ID = 'dictionary-download';
DownloadableList.prototype.LIST_ELEMENT_ID = 'dictionary-download-list';

// JSON file lists downloaded dictionaries, generated by build script.
DownloadableList.prototype.DICT_FILE_PATH = './js/settings/dictionaries.json';

DownloadableList.prototype.start = function() {
  this.sectionElement = document.getElementById(this.SECTION_ELEMENT_ID);
  this.listElement = document.getElementById(this.LIST_ELEMENT_ID);
  this.database = new DatabasePromiseManager();
  this.database.start();

  this.downloadables = new Map();

  this._getDictListJSON().then(function(dictList) {
    this._showListUI(dictList);

    var unpreloadedDictNames = dictList.filter(function(dict) {
      return !dict.preloaded;
    }).map(function(dict) {
      return dict.name;
    });

    return Promise.all([unpreloadedDictNames,
                        this.database.getItems(unpreloadedDictNames)]);
  }.bind(this)).then(function(values) {
    var loadedDictNames = values[0].filter(function(name, i) {
      return !!values[1][i];
    });

    this._setDownloaded(loadedDictNames);
  }.bind(this)).catch(function(e) {
    e && console.error(e);
  });
};

DownloadableList.prototype._getDictListJSON = function() {
  var p = new Promise(function(resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', this.DICT_FILE_PATH);
    xhr.responseType = 'json';
    xhr.onload = function() {
      if (xhr.response) {
        resolve(xhr.response);
      } else {
        reject();
      }
    };
    xhr.onerror = function() {
      reject();
    };
    xhr.send();

  }.bind(this));

  return p;
};

DownloadableList.prototype._showListUI = function(dictList) {
  var needDownload = dictList.some(function(dict) {
    return (dict.preloaded === false);
  });

  // If the enabled layouts and the dictionary preloaded layouts are of
  // the same amount, we don't really need to enable the downloadable
  // dictionary feature.
  if (!needDownload) {
    return;
  }

  this.sectionElement.classList.remove('hide');

  dictList.sort(function(a, b) {
    return (a.name - b.name);
  }).forEach(function(dict) {
    var item = new Downloadable(this.database, {
      label: dict.label,
      preloaded: dict.preloaded,
      name: dict.name
    });
    item.start();

    this.listElement.appendChild(item.element);
    this.downloadables.set(dict.name, item);
  }, this);
};

DownloadableList.prototype._setDownloaded = function(loadedDictList) {
  this.downloadables.forEach(function(item, name) {
    var downloaded = (loadedDictList.indexOf(name) !== -1);

    item.setDownloaded(downloaded);
  });
};

exports.DownloadableList = DownloadableList;

}(window));
