<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: controllers/timer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: controllers/timer.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>define(function(require, exports, module) {
'use strict';

/**
 * Dependencies
 */

var debug = require('debug')('controller:timer');
var TimerView = require('views/timer');
var bindAll = require('lib/bind-all');

/**
 * Exports
 */

module.exports = function(app) { return new TimerController(app); };
module.exports.TimerController = TimerController;

/**
 * Create a new `TimerController`
 *
 * We make the setup method async so
 * that events are not called in the
 * same synchronous turn in which they
 * are bound.
 *
 * Events:
 *
 *   - 'timer:immanent' - The timer is close to ending
 *   - 'timer:started' - The timer has begun counting down
 *   - 'timer:cleared' - The countdown was canceled
 *   - 'timer:ended' - The timer finished counting down
 *
 * @param {App} app [description]
 */
function TimerController(app) {
  bindAll(this);
  this.app = app;
  this.settings = app.settings;
  this.view = app.views.timer || new TimerView();
  this.view.appendTo(app.el);
  this.bindEvents();
  debug('initialized');
}

/**
 * Connects the timer view
 * with the app via events.
 *
 * @private
 */
TimerController.prototype.bindEvents = function() {
  this.app.on('startcountdown', this.start);
  this.app.on('hidden', this.clear);
  this.app.on('change:batteryStatus', this.onBatteryChanged);
  this.view.on('timer:immanent', this.app.firer('timer:immanent'));
};

/**
 * Start the timer counting down
 * from the currently set timer value.
 *
 * Don't allow timer to start if
 * one is already active.
 *
 * We bind to app events asynchronously
 * so that the timer isn't instantly
 * cleared by the 'click' that started it.
 *
 * @private
 */
TimerController.prototype.start = function() {
  if (this.app.get('timerActive')) { return; }

  this.seconds = this.settings.timer.selected('value');
  this.view.set(this.seconds).show();
  setTimeout(this.bindTimerEvents);
  this.scheduleTick();

  this.app.set('timerActive', true);
  this.app.emit('timer:started');

  debug('started');
};

/**
 * Schedule the next tick.
 *
 * Make sure to clear any existing
 * timeout to be absolutely sure that
 * only one timeout is ever pending.
 *
 * @private
 */
TimerController.prototype.scheduleTick = function() {
  clearTimeout(this.timeout);
  this.timeout = setTimeout(this.tick, 1000);
};

/**
 * Decrements the timer and checks
 * if its still has second left.
 *
 * If no time remains, the timer
 * has ended.
 *
 * If time does remain, we update
 * the view.
 *
 * @private
 */
TimerController.prototype.tick = function() {
  if (--this.seconds &lt;= 0) {
    this.onEnded();
    return;
  }

  this.view.set(this.seconds);
  this.scheduleTick();
};

TimerController.prototype.onEnded = function() {
  this.app.emit('timer:ended');
  this._clear();
};

TimerController.prototype.onBatteryChanged = function(status) {
  if (status === 'shutdown') {
    this.clear();
  }
};

/**
 * Call ._clear() and fire 'cleared' event.
 *
 * @param  {Object} options
 * @private
 */
TimerController.prototype.clear = function() {
  this._clear();
  this.app.emit('timer:cleared');
};

/**
 * Clear the timer and hide
 * the view.
 *
 * @param  {Object} options
 * @private
 */
TimerController.prototype._clear = function() {
  clearTimeout(this.timeout);
  this.unbindTimerEvents();
  this.view.hide();
  this.view.reset();
  this.app.set('timerActive', false);
  debug('cleared');
};

/**
 * When the app is clicked we cancel
 * the timer. Also respond to when the
 * timer is cleared, or ends.
 *
 * These events are only bound when
 * the timer is counting to avoid complex
 * conflicts with other app interactions
 * when not needed.
 *
 * @private
 */
TimerController.prototype.bindTimerEvents = function() {
  this.app.on('click', this.clear);
};

/**
 * Unbind the timer events when
 * they are no longer needed.
 *
 * @private
 */
TimerController.prototype.unbindTimerEvents = function() {
  this.app.off('click', this.clear);
};

});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module.html#.exports">exports</a></li></ul><h3>Global</h3><ul><li><a href="global.html"></a></li><li><a href="global.html#bindEvents">bindEvents</a></li><li><a href="global.html#clear">clear</a></li><li><a href="global.html#display">display</a></li><li><a href="global.html#getSize">getSize</a></li><li><a href="global.html#hide">hide</a></li><li><a href="global.html#localize">localize</a></li><li><a href="global.html#onShutterEnd">onShutterEnd</a></li><li><a href="global.html#set">set</a></li><li><a href="global.html#setScreenReaderVisible">setScreenReaderVisible</a></li><li><a href="global.html#setupSwitch">setupSwitch</a></li><li><a href="global.html#setZoom">setZoom</a></li><li><a href="global.html#setZoomPreviewAdjustment">setZoomPreviewAdjustment</a></li><li><a href="global.html#show">show</a></li><li><a href="global.html#shutter">shutter</a></li><li><a href="global.html#updatePreview">updatePreview</a></li><li><a href="global.html#updatePreviewMetrics">updatePreviewMetrics</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.1</a> on Tue Jun 23 2015 13:12:33 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
