'use strict';

/* globals SimplePhoneMatcher, Normalizer, contacts, MultiContact, Promise */
/* exported GlobalContacts */

/*
 * Module for working with the Global Contacts DataStore (GCDS).
 *
 * This module will deal with the object stored, that follow
 * this structure:
 * {
 *   id: <Generated by the Global Contacts Datastore>
 *   sequence<entry>
 * }
 * where entry is an object like: { uid: <originDsId>, origin: <OriginDs> }
 * <originDsId> contains all the information that allows to locate that
 *              particular datastore
 *
*/

var GlobalContacts = (function GCDSOps() {
  const NAME = 'Global_Contacts_Datastore';

  // Record id that will hold the index data
  const INDEX_ID = 1;
  const DS_LOADED_EVENT = 'datastore_loaded';
  const FIELD_INDEX = Object.freeze({
    'name': 'byName',
    'givenName': 'byGivenName',
    'familyName': 'byFamilyName'
  });

  var isIndexDirty = false;

  var matcher = new contacts.MatcherObj();

  /**
   * This promise holds the reference to the GCD
   * @type {Promise}
   */
  var storePromise = new Promise((resolve, reject) => {
    if (!navigator.getDataStores) {
      return reject(new Error('DatastoreNotEnabled'));
    }

    return navigator.getDataStores(NAME).then(stores => stores[0]);
  });

  /**
   * This promise holds the reference to the record that holds the index data
   * @type {Promise}
   */
  var indexPromise = storePromise.then(store => {
    return store.get(INDEX_ID).then(idx => {
      isIndexDirty = false;
      return idx;
    }).catch(() => {
      var idx = createIndex();
      store.add(idx);
      return idx;
    });
  };

  function createIndex() {
    return {
      // Will contain all the index of contacts that come from a
      // specific store, indexed by contact uid
      byStore: Object.create(null),

      // By tel number and all its possible variants
      // (We are not supporting dups right now)
      byTel: Object.create(null),
      byEmail: Object.create(null),

      // We need this indexes in order to perform passive matching
      byName: Object.create(null),
      byGivenName: Object.create(null),
      byFamilyName: Object.create(null)
    };
  }

  function setIndex(obj) {
    return index = obj || createIndex();
  }

  function indexByPhone(contact, originStore, originDsId, globalDsId) {
    if (!Array.isArray(contact.tel)) {
      return Promise.reject();
    }

    return indexPromise.then(index => {
      contact.tel.forEach(tel => {
        var variants = SimplePhoneMatcher.generateVariants(tel.value);

        variants.forEach(variant => {
          var indexEntry = index.byTel[variant] || [];

          // An entry on the index holds the globalDsId and the local DS info
          // (owner, uid). This is needed because we need to know the origin of
          // that index when a local DS contact is removed.
          indexEntry.push({
            id: globalDsId,
            uid: originDsId,
            owner: originStore.owner
          });

          index.byTel[variant] = indexEntry;
        });
      });
    });
  }

  function indexByEmail(contact, originStore, originDsId, globalDsId) {
    if (!Array.isArray(contact.email)) {
      return Promise.reject();
    }

    return indexPromise.then(index => {
      contact.email.forEach(email => {
        if (!index.byEmail[email.value]) {
          index.byEmail[email.value] = [];
        }

        index.byEmail[email.value].push({
          id: globalDsId,
          owner: originStore.owner,
          uid: originDsId
        });
      });
    });
  }

  function indexByStore(originStore, originDsId, globalDsId) {
    return indexPromise.then(index => {
      var storeIndex = index.byStore[originStore.owner];
      if (!storeIndex) {
        storeIndex = {};
        index.byStore[originStore.owner] = storeIndex;
      }

      storeIndex[originDsId] = globalDsId;
    });
  }

  function normalizeName(str) {
    if (!str || !str.trim()) {
      return '';
    }

    return Normalizer.toAscii(str.trim().toLowerCase());
  }

  function indexByNames(contact, originStore, originDsId, globalDsId) {
    return indexPromise.then(index => {
      Object.keys(FIELD_INDEX).forEach(field => {
        var contactField = contact[field];
        var fieldIndex = index[FIELD_INDEX[field]];

        if (Array.isArray(contactField) &&
            contactField[0] &&
              contactField[0].trim()) {

          let normalizedName = normalizeName(contactField[0]);
          let indexEntry = fieldIndex[normalizedName] || [];

          indexEntry.push({
            id: globalDsId,
            owner: originStore.owner,
            uid: originDsId
          });

          fieldIndex[normalizedName] = indexEntry;
        }
      });
    });
  }

  function indexEntry(originStore, entryUid, globalDsId, contact) {
    return indexByPhone(contact, originStore, entryUid, globalDsId)
      .then(() => indexByEmail(contact, originStore, entryUid, globalDsId))
      .then(() => indexByNames(contact, originStore, entryUid, globalDsId))
      .then(() => {
        isIndexDirty = true;
        return indexByStore(originStore, entryUid, globalDsId);
      });
  }

  /**
   *
   *   Adds a new object to the global DS originStore is the Store origin
   *   originStoreId is the object id in the origin datastore
   *
   */

  var add = function add(originStore, originDsId, contact) {
    var entry = {
      uid: originDsId,
      origin: originStore.owner
    };

    return new Promise(function(resolve, reject) {
      var callbacks = {
        onmatch: function(results) {
          var key = Object.keys(results)[0];
          var entryIdToMerge = results[key].matchingContact.id;

          doAppend(entry, originStore, entryIdToMerge, contact)
            .then(resolve, reject);
        },
        onmismatch: function() {
          doAdd(entry, originStore, contact).then(resolve, reject);
        }
      };

      // The data provider will enable the contacts matcher to search for
      // contacts in this datastore and find the corresponding duplicates
      matcher.dataProvider = GlobalContacts;
      matcher.match(contact, 'passive', callbacks);
    });
  };

  // Adds a new contact. Then it is indexed
  function doAdd(entry, originStore, contact) {
    return storePromise
      .then(store => store.add([entry]))
      .then(globalDsId => {
        return indexEntry(originStore, entry.uid, globalDsId, contact);
      });
    });
  }

  // Append a contact to an specific index
  function doAppend(entry, originStore, globalDsId, contact) {
    return storePromise
      .then(store => store.get(globalDsId))
      .then((obj = []) => store.put(obj.concat(entry), globalDsId))
      .then(() => indexEntry(originStore, entry.uid, globalDsId, contact))
  }

  // Get a list of all contacts by this DS and perform
  // remove operations over it.
  var clear = function clear(originStore) {
    Promise.all([storePromise, indexPromise]).then((store, index) => {
      return store.then(function success(store) {

        // All the GCDS is cleared
        if (!originStore) {
          setIndex();
          isIndexDirty = true;

          return store.clear().then(() => flush());
        }

        var byStore = index.byStore[originStore.owner];
        if (!byStore) {
          return Promise.reject(new Error('DatastoreNotFound'));
        }

        var actions =
          Object.keys(byStore).map(key => remove(originStore, key));

        return Promise.all(actions);
      });
    });
  };

  // Removes a contact from the DS, de-indexing it
  function remove(originStore, originDsId, contact) {
    var globalDsId;
    return storePromise.then(store => {
      var error;
      var byStore = index.byStore[originStore.owner];
      if (!byStore) {
        error = 'DatastoreNotFound';
      }

      globalDsId = byStore[originDsId];
      if (!globalDsId) {
        error = 'NotFound';
      }

      if (error) {
        return Promise.reject(new Error(error));
      }

      return store.get(globalDsId);
    }).then(entryList => {
      return doRemove(entryList, originStore, originDsId, globalDsId, contact);
    });
  };

  /**
   * Removes one component from a contact. We have two cases, a contact
   * with a single component (direct), or a contact that is compound
   * by several entries
   *
   * @param entryList Array of objects containing the components of a contact
   * @param originStore Source datastore for the component we want remove
   * @param originDsId index of the global merged contact
   * @param globalDsId index of the contact in the origin datastore
   */
  function doRemove(entryList, originStore, originDsId, globalDsId, contact) {
    return new Promise(function(resolve, reject) {
      var position = -1;
      entryList.forEach(function onEntry(entry, i) {
        if (entry.origin === originStore.owner && entry.uid === originDsId) {
          position = i;
        }
      });

      if (position !== -1) {
        entryList.splice(position, 1);
      }

      removeIndexes(originStore, originDsId, globalDsId, contact);

      // Update entry or remove it depending on how many are now present
      var action;
      if (entryList.length === 0) {
        action = store.remove(globalDsId);
      } else {
        action = store.put(entryList, globalDsId);
      }

      action.then(resolve, reject);
    });
  }

  function removeIndexes(originStore, originDsId, globalDsId, contact) {
    removePhoneIndex(originStore, originDsId, globalDsId, contact);
    removeEmailIndex(originStore, originDsId, globalDsId, contact);
    removeDatastoreIndex(originStore, globalDsId, originDsId);
    removeNameIndexes(originStore, originDsId, globalDsId, contact);

    isIndexDirty = true;
  }

  // This function is used to find a corresponding target element on the index
  // Allowing us to remove it when it is no longer necessary
  // The matching must correspond to the same GCDS id, owner and DS UID
  function fnIndex(target, element) {
    return target.id && element.id === target.id &&
            element.owner === target.owner && element.uid === target.uid;
  }

  function removeAllFromIndex(originStore, indexField) {
    var items = Object.keys(index[indexField]);

    items.forEach(function(item) {
      var entryArray = index[indexField][item];
      var newEntryArray = [];
      for (var j = 0; j < entryArray.length; j++) {
        if (entryArray[j].owner !== originStore.owner) {
          newEntryArray.push(entryArray[j]);
        }
      }
      if (newEntryArray.length > 0) {
        index[indexField][item] = newEntryArray;
      }
      else {
        delete index[indexField][item];
      }
    });

    return;
  }

  function removePhoneIndex(originStore, originDsId, globalDsId,
                            deletedContact) {
    // If there is no contact to delete then all the store pointers are removed
    // from the index
    if (!deletedContact) {
      removeAllFromIndex(originStore, 'byTel');
      return;
    }

    var fnIndexBounded = fnIndex.bind(null, {
      id: globalDsId,
      owner: originStore.owner,
      uid: originDsId
    });

    // Need to update the tel indexes
    if (Array.isArray(deletedContact.tel)) {
      deletedContact.tel.forEach(function(aTel) {
        var variants = SimplePhoneMatcher.generateVariants(aTel.value);

        variants.forEach(function(aVariant) {
          var indexEntry = index.byTel[aVariant];
          if (Array.isArray(indexEntry)) {
            var position = indexEntry.findIndex(fnIndexBounded);

            if (position !== -1) {
              indexEntry.splice(position, 1);
              if (indexEntry.length === 0) {
                delete index.byTel[aVariant];
              }
            }
          }
        });
      });
    }
  }

  function removeDatastoreIndex(originStore, globalDsId, originDsId) {
    var storeIndex = index.byStore[originStore.owner];
    if (storeIndex) {
       delete storeIndex[originDsId];

      if (Object.keys(storeIndex).length === 0) {
        delete index.byStore[originStore.owner];
      }
    }
  }

  function removeEmailIndex(originStore, originDsId, globalDsId, contact) {
    // If there is no contact to delete then all the store pointers are removed
    // from the index
    if (!contact) {
      removeAllFromIndex(originStore, 'byEmail');
      return;
    }

    var fnIndexBounded = fnIndex.bind(null, {
      id: globalDsId,
      owner: originStore.owner,
      uid: originDsId
    });

    if (Array.isArray(contact.email)) {
      contact.email.forEach(function(aEmail) {
        if (aEmail.value) {
          var indexEntry = index.byEmail[aEmail.value];
          if (Array.isArray(indexEntry)) {
            var idx = indexEntry.findIndex(fnIndexBounded);
            if (idx !== -1) {
              indexEntry.splice(idx, 1);
              if (indexEntry.length === 0) {
                delete index.byEmail[aEmail.value];
              }
            }
          }
        }
      });
    }
  }

  function removeNameIndexes(originStore, originDsId, globalDsId, contact) {
    Object.keys(FIELD_INDEX).forEach(function(aField) {
      if (!contact) {
        removeAllFromIndex(originStore, FIELD_INDEX[aField]);
        return;
      }

      var contactField = contact[aField];
      var fieldIndex = index[FIELD_INDEX[aField]];

      var fnIndexBounded = fnIndex.bind(null, {
        id: globalDsId,
        owner: originStore.owner,
        uid: originDsId
      });

      if (Array.isArray(contactField) &&
          contactField[0] &&
          contactField[0].trim()) {

        var normalizedName = normalizeName(contactField[0]);
        var indexEntry = fieldIndex[normalizedName];

        if (Array.isArray(indexEntry)) {
          var idx = indexEntry.findIndex(fnIndexBounded);
          if (idx !== -1) {
            fieldIndex[normalizedName].splice(idx, 1);
            if (fieldIndex[normalizedName].length === 0) {
              delete fieldIndex[normalizedName];
            }
          }
        }
      }
    });
  }

  /**
   *  Returns just an entry on GCDS
   *
   */
   var getEntry = function getEntry(globalDsId) {
    return store.then(function success(store) {
      return store.get(globalDsId);
    });
  };

  /**
   *  Returns all the data (merged contact) corresponding
   *  to the GCDS entry
   *
   */
  var getData = function getData(globalDsId) {
    return getEntry(globalDsId).then(entry => {
      return MultiContact.getData({
        id: globalDsId,
        entryData: entry
      });
    });
  };

  var findBy = function findBy(field, strToFind) {
    return store.then(store => {
      var contactIds;

      switch (field) {
        case 'tel':
          var variants = SimplePhoneMatcher.generateVariants(strToFind);
          variants.forEach(function(aVariant) {
            var ids = index.byTel[aVariant];

            if (Array.isArray(ids)) {
              contactIds = ids.map(ct => ct.id);
            }
          });
        break;

        case 'email':
          contactIds = index.byEmail[strToFind].map(ct => ct.id);
        break;

        case 'name':
        case 'givenName':
        case 'familyName':
          var indexEntry = index[FIELD_INDEX[field]];
          var strNormalized = normalizeName(strToFind);
          contactIds = indexEntry[strNormalized].map(ct => ct.id);
        break;
      }

      if (!Array.isArray(contactIds) || contactIds.length === 0) {
        return Promise.resolve([]);
      }

      // Ensure unique entries by using a Set
      return getContactData(new Set(contactIds));
    });
  };

  function getContactData(contactIds) {
    contactIds = [...contactIds]; // convert set to array
    store.get.apply(store, contactIds).then(entries => {
      if (contactIds.length === 1) {
        entries = [entries];
      }

      var operations = entries.map((aEntry, i) => {
        return MultiContact.getData({
          id: contactIds[i],
          entryData: aEntry
        });
      });

      return Promise.all(operations);
    });
  }

  // This is needed for the contacts matcher module to adapt to the
  // expected interface
  var findAdapter = function findAdapter(options) {
    var by = options.filterBy[0];
    var targetValue = options.filterValue;

    return {
      set onsuccess(cb) {
        findBy(by, targetValue).then(result => {
          this.result = result;
          cb();
        }, this.errorCb);
      },
      set onerror(errorCb) {
        this.errorCb = errorCb;
      }
    };
  };

  function flush() {
    return Promise.all([storePromise, indexPromise]).then((store, index) => {
      if (!isIndexDirty) {
        return Promise.resolve();
      }
      isIndexDirty = false;
      return store.put(index, INDEX_ID);
    });
  };

  return {
    add,
    remove,
    flush,
    clear,
    getEntry,
    getData,
    get revisionId() { return store.revisionId; },
    findBy,
    find: findAdapter
  };

})();
